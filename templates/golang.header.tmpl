// AUTOGENERATED BY gopkg.in/spacemonkeygo/dbx.v1
// DO NOT EDIT.

package {{ .Package }}

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"
	"strconv"
	"strings"

{{- range .ExtraImports }}
	{{ . }}
{{- end }}
)

// Prevent conditional imports from causing build failures
var _ = strconv.Itoa
var _ = strings.LastIndex
var _ = fmt.Sprint

var (
	WrapErr = func(err *Error) error {return err}
	Now		= time.Now
	Logger func(format string, args ...interface{})

	errTooManyRows = errors.New("too many rows")
	errUnsupportedDriver = errors.New("unsupported driver")
	errEmptyUpdate = errors.New("empty update")
)

type ErrorCode int

const (
	ErrorCode_Unknown ErrorCode = iota
	ErrorCode_UnsupportedDriver
	ErrorCode_NoRows
	ErrorCode_TxDone
	ErrorCode_TooManyRows
	ErrorCode_ConstraintViolation
	ErrorCode_EmptyUpdate
)

type Error struct {
	Err error
	Code ErrorCode
	Driver string
	Constraint string
}

func (e *Error) Error() string {
	return e.Err.Error()
}

func wrapErr(e *Error) error {
	if WrapErr == nil {
		return e
	}
	return WrapErr(e)
}

func makeErr(err error) error {
	if err == nil {
		return nil
	}
	e := &Error{Err: err}
	switch err {
	case sql.ErrNoRows:
		e.Code = ErrorCode_NoRows
	case sql.ErrTxDone:
		e.Code = ErrorCode_TxDone
	}
	return wrapErr(e)
}

func unsupportedDriver(driver string) error {
	return wrapErr(&Error{
		Err: errUnsupportedDriver,
		Code: ErrorCode_UnsupportedDriver,
		Driver: driver,
	})
}

func emptyUpdate() error {
	return wrapErr(&Error{
		Err: errEmptyUpdate,
		Code: ErrorCode_EmptyUpdate,
	})
}

func tooManyRows() error {
	return wrapErr(&Error{
		Err: errTooManyRows,
		Code: ErrorCode_TooManyRows,
	})
}

func constraintViolation(err error, constraint string) error {
	return wrapErr(&Error{
		Err: err,
		Code: ErrorCode_ConstraintViolation,
		Constraint: constraint,
	})
}

type driver interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
}

var (
	notAPointer = errors.New("destination not a pointer")
	lossyConversion = errors.New("lossy conversion")
)

type DB struct {
	*sql.DB
	dbMethods
}

func Open(driver, source string) (db *DB, err error) {
	sql_db, err := sql.Open(driver, source)
	if err != nil {
		return nil, makeErr(err)
	}
	defer func(sql_db *sql.DB) {
		if err != nil {
			sql_db.Close()
		}
	}(sql_db)

	if err := sql_db.Ping(); err != nil {
		return nil, makeErr(err)
	}

	var impl dbMethods
	switch driver {
{{- range .Dialects }}
	case {{ .Name | printf "%q" }}:
		impl = new{{ .Name }}(sql_db)
{{- range .ExecOnOpen }}
		if _,  err := sql_db.Exec({{ printf "%q" . }}); err != nil {
			return nil, impl.makeErr(err)
		}
{{- end }}
{{- end }}
	default:
		return nil, unsupportedDriver(driver)
	}

	return &DB{
		DB: sql_db,
		dbMethods: impl,
	}, nil
}

func (obj *DB) Close() (err error) {
	return obj.makeErr(obj.DB.Close())
}

func (obj *DB) Open(ctx context.Context) (*Tx, error) {
	tx, err := obj.DB.Begin()
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return &Tx{
		tx: tx,
		txMethods: obj.wrapTx(tx),
	}, nil
}

func DeleteAll(ctx context.Context, db *DB) (int64, error) {
	tx, err := db.Open(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err == nil {
			err = db.makeErr(tx.Commit())
			return
		}

		if err_rollback := tx.Rollback(); err_rollback != nil {
			if Logger != nil {
				Logger("delete-all: rollback failed: %v", db.makeErr(err_rollback))
			}
		}
	}()
	return tx.deleteAll(ctx)
}

type Tx struct {
	tx *sql.Tx
	txMethods
}

type dialectTx struct {
	tx *sql.Tx
}

func (tx *dialectTx) Commit() (err error) {
	return makeErr(tx.tx.Commit())
}

func (tx *dialectTx) Rollback() (err error) {
	return makeErr(tx.tx.Rollback())
}

{{- range .Dialects }}

{{- $dbtype := .Name | printf "%sDB" -}}
{{- $txtype := .Name | printf "%sTx" -}}
{{- $impltype := .Name | printf "%sImpl" }}

type {{ $impltype }} struct {
	driver driver
}

func (obj *{{ $impltype }}) logStmt(stmt string, args... interface{}) {
	{{ .Name }}LogStmt(stmt, args...)
}

func (obj *{{ $impltype }}) makeErr(err error) error {
	 constraint, ok := obj.isConstraintError(err)
	 if ok {
		 return constraintViolation(err, constraint)
	 }
	 return makeErr(err)
}

type {{ $dbtype }} struct {
	db *sql.DB
	*{{ $impltype }}
}

func new{{ .Name }}(db *sql.DB) *{{ $dbtype }} {
	return &{{ $dbtype }}{
		db: db,
		{{ $impltype }}: &{{ $impltype }}{
			driver: db,
		},
	}
}

func (obj *{{ $dbtype }}) Schema() string {
	return `{{ .SchemaSQL }}`
}

func (obj *{{ $dbtype }}) wrapTx(tx *sql.Tx) txMethods {
	return &{{ $txtype }}{
		dialectTx: dialectTx{tx: tx},
		{{ $impltype }}: &{{ $impltype }}{
			driver: tx,
		},
	}
}

type {{ $txtype }} struct {
	dialectTx
	*{{ $impltype }}
}

func {{ .Name }}LogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		Logger("sql:\n%s\nargs:\n%q", stmt, args)
	}
}

{{- end }}

{{ range .Structs }}
{{- $struct := .Name -}}
{{- $createstruct := .CreateStructName -}}
{{- $updatestruct := .UpdateStructName }}

type {{ $struct }} struct {
{{- range .Fields }}
	{{ .Name }} {{ .Type }}
{{- end }}
}

func ({{ $struct }}) _Table() string { return "{{ .Table }}" }

{{- if .OptionalInsertFields }}

type {{ $createstruct }} struct {
{{- range .OptionalInsertFields }}
	{{ .Name }} {{ .StructName }}
{{- end }}
}

{{- end }}

type {{ $updatestruct }} struct {
{{- range .UpdatableFields }}
	{{ .Name }} {{ .StructName }}
{{- end }}
}

{{- range .Fields }}
{{- $fstruct := .StructName }}
{{- $ctor := printf "%s_%s" .ModelName .Name }}

type {{ $fstruct }} struct {
	_set bool
	_value {{ .Type }}
}

func {{ $ctor }}(v {{ .CtorValue }}) {{ $fstruct }} {
{{- if .MutateFn }}
	v = {{ .MutateFn }}(v)
{{- end }}
	return {{ $fstruct }}{ _set: true, _value: {{ if .TakeAddr }}&{{ end }}v }
}
{{ if .Nullable }}
func {{ $ctor }}_Raw(v {{ .Type }}) {{ $fstruct }} {
	if v == nil {
		return {{ $ctor }}_Null()
	}
	return {{ $ctor }}({{ if .TakeAddr }}*{{ end }}v)
}

func {{ $ctor }}_Null() {{ $fstruct }} {
	return {{ $fstruct }}{ _set: true }
}
{{ end }}

func (f {{ $fstruct }}) value() interface{} { if !f._set { return nil }; return f._value }

func ({{ $fstruct }}) _Column() string { return "{{ .Column }}" }

{{- end -}}
{{- end }}

func toUTC(t time.Time) time.Time {
	return t.UTC()
}
