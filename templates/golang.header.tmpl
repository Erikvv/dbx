// AUTOGENERATED BY gopkg.in/spacemonkeygo/dbx.v0
// DO NOT EDIT.

package {{ .Package }}

import (
	"database/sql"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/jmoiron/sqlx"
{{- range .Dialects }}
	_ "{{ .Driver }}"
{{- end }}
)

var WrapErr = func(err error) error {return err}
var Logger func(format string, args ...interface{})
var Now = time.Now

func loge(err error) {
	if Logger != nil && err != nil {
		Logger("error closing statement: %v", err)
	}
}

{{ range .Structs }}
type {{ .Name }} struct {
{{- range .Fields }}
	{{ .Name }} {{ .Type }} {{ .Tag }}
{{- end }}
}

{{- if .Updatable }}
{{ $struct := .Name }}
type {{ $struct }}Update interface {
	columnName() string
	value() interface{}
	private{{ $struct }}()
}
{{ range .UpdatableFields }}
{{ $upstruct := printf "%s%s" (cameldown $struct) .Name }}
type {{ $upstruct }} {{ .Type }}
func {{ $struct }}{{ .Name }}(v {{ .Type }}) {{ $struct }}Update { return {{ $upstruct }}(v) }
func (u {{ $upstruct }}) columnName() string { return "{{ .Column }}" }
func (u {{ $upstruct }}) value() interface{} { return {{ .Type }}(u) }
func (u {{ $upstruct }}) private{{ $struct }}() {}
{{- end -}}
{{- end -}}
{{- end }}

type DB struct {
	*sqlx.DB
    lru *lru
    impl implMethods
}

func Open(driver, source string, lru_size int) (*DB, error) {
	db, err := sqlx.Connect(driver, source)
	if err != nil {
		return nil, WrapErr(err)
	}
	
    lru := newLRU(db, lru_size)

    var impl implMethods
    switch driver {
{{- range .Dialects }}
    case {{ .Name | printf "%q" }}:
		impl = &{{ .Name }}DB{lru: lru}
{{- end }}
    default:
        return nil, WrapErr(fmt.Errorf("unsupported driver %s", driver))
    }

	return &DB{
		DB: db,
		lru: lru,
        impl: impl,
	}, nil
}

func (obj *DB) Close() (err error) {
    obj.impl = nil
	obj.lru.Purge()
	return WrapErr(obj.DB.Close())
}

func (obj *DB) Schema() string {
	return obj.impl.schema()
}

func (obj *DB) DeleteAll() (total int64, err error) {
{{- range .StructsReverse }}
    if n, err := obj.impl.Delete{{ pluralize .Name }}(); err == nil {
        total += n
    } else {
        return total, WrapErr(err)
    }
{{- end }}
    return total, nil
}

func (obj *DB) Open() (*Tx, error) {
	tx, err := obj.DB.Beginx()
	if err != nil {
		return nil, WrapErr(err)
	}

    return &Tx{Tx: tx, impl: obj.impl.begin(tx)}, nil
}

type Tx struct {
	*sqlx.Tx
    impl methods
}

func (tx *Tx) Commit() (err error) {
    tx.impl = nil
	return WrapErr(tx.Tx.Commit())
}

func (tx *Tx) Rollback() (err error) {
    tx.impl = nil
	return WrapErr(tx.Tx.Rollback())
}

func (tx *Tx) DeleteAll() (total int64, err error) {
{{- range .StructsReverse }}
    if n, err := tx.impl.Delete{{ pluralize .Name }}(); err == nil {
        total += n
    } else {
        return total, WrapErr(err)
    }
{{- end }}
    return total, nil
}

{{- range .Dialects }}

{{ $dbtype := .Name | printf "%sDB" }}
{{ $txtype := .Name | printf "%sTx" }}

type {{ $dbtype }} struct {
	lru *lru
}

func (obj *{{ $dbtype }}) schema() string {
return `
{{- .SchemaSQL -}}
`
}

func (obj *{{ $dbtype }}) prepare(stmt string) (prepared *sqlx.Stmt, replace func(), err error) {
	entry, err := obj.lru.Get(stmt)
	if err != nil {
		return nil, nil, err
	}
	return entry.Stmt, func() { obj.lru.Replace(entry) }, nil
}

func (obj *{{ $dbtype }}) logStmt(stmt string, args... interface{}) {
	{{ .Name }}LogStmt(stmt, args...)
}

func (obj *{{ $dbtype }}) begin(tx *sqlx.Tx) methods {
	return &{{ $txtype }}{
		tx: tx,
		lru: obj.lru,
	}
}

type {{ $txtype }} struct {
	tx *sqlx.Tx
	lru *lru
}

func (obj *{{ $txtype }}) prepare(stmt string) (prepared *sqlx.Stmt, replace func(), err error) {
	entry, err := obj.lru.Get(stmt)
	if err != nil {
		return nil, nil, err
	}
	return obj.tx.Stmtx(entry.Stmt), func() { obj.lru.Replace(entry) }, nil
}

func (obj *{{ $txtype }}) logStmt(stmt string, args... interface{}) {
	{{ .Name }}LogStmt(stmt, args...)
}

func {{ .Name }}LogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		Logger("sql:\n%s\nargs:\n%v", stmt, args)
	}
}

{{- end }}

type entry struct {
	Stmt *sqlx.Stmt

	next, prev *entry
	key        string
	refs       int
}

type lru struct {
	mu       sync.Mutex
	db       *sqlx.DB
	capacity int
	root     entry
	index    map[string]*entry
}

// newLRU returns an initialized lru.
func newLRU(db *sqlx.DB, capacity int) *lru {
	l := &lru{
		db:       db,
		capacity: capacity,
		index:    make(map[string]*entry),
	}
	l.root.next = &l.root
	l.root.prev = &l.root
	return l
}

// insert inserts e after at, increments l.len.
func (l *lru) insert(e, at *entry) {
	n := at.next
	at.next = e
	e.prev = at
	e.next = n
	n.prev = e
}

// remove removes e from its list, decrements l.len
func (l *lru) remove(e *entry) {
	e.prev.next = e.next
	e.next.prev = e.prev
	e.next = nil // avoid memory leaks
	e.prev = nil // avoid memory leaks
}

func (l *lru) evict(capacity int) {
	if capacity < 0 {
		return
	}

	to_evict := len(l.index) - capacity
	current := &l.root
	for i := 0; i < to_evict; i++ {
		current = current.prev
		if current == &l.root {
			panic("index out of whack. race conditions?")
		}
		if current.refs > 0 {
			continue
		}
		// whoa boy is this subtle. l.remove blows away current.next and
		// current.prev. but current.next.prev will be mutated to be
		// current.prev for the next iteration!
		next_current := current.next

		l.remove(current)
		delete(l.index, current.key)
		loge(current.Stmt.Close())

		current = next_current
	}
}

func (l *lru) Get(key string) (*entry, error) {
	l.mu.Lock()
	defer l.mu.Unlock()

	e, ok := l.index[key]
	if ok {
		l.remove(e)
		l.insert(e, &l.root)
		e.refs++

		return e, nil
	}

	stmt, err := l.db.Preparex(l.db.Rebind(key))
	if err != nil {
		return nil, WrapErr(err)
	}

	e = &entry{
		Stmt: stmt,
		key:   key,
	}
	l.insert(e, &l.root)
	l.index[key] = e
	e.refs++

	return e, nil
}

func (l *lru) Replace(e *entry) {
	l.mu.Lock()
	defer l.mu.Unlock()

	e.refs--
	l.evict(l.capacity)
}

func (l *lru) Purge() {
	l.mu.Lock()
	defer l.mu.Unlock()

	l.evict(0)
}


