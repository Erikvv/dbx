// AUTOGENERATED BY gopkg.in/spacemonkeygo/dbx.v0
// DO NOT EDIT.

package {{ .Package }}

import (
	"database/sql"
	"fmt"
	"time"
	"strconv"

{{- range .ExtraImports }}
	{{ .As }} "{{ .Package }}"
{{- end }}
)

var WrapErr = func(err error) error {return err}
var Logger func(format string, args ...interface{})
var Now = time.Now

type DB struct {
	*sql.DB
	dbMethods
}

func Open(driver, source string) (*DB, error) {
	db, err := sql.Open(driver, source)
	if err != nil {
		return nil, WrapErr(err)
	}
	
	var impl dbMethods
	switch driver {
{{- range .Dialects }}
	case {{ .Name | printf "%q" }}:
		impl = &{{ .Name }}DB{impl: db}
{{- end }}
	default:
		return nil, WrapErr(fmt.Errorf("unsupported driver %s", driver))
	}

	return &DB{
		DB: db,
		dbMethods: impl,
	}, nil
}

func (obj *DB) Close() (err error) {
	return WrapErr(obj.DB.Close())
}

func (obj *DB) DeleteAll() (total int64, err error) {
{{- range .StructsReverse }}
	if n, err := obj.Delete{{ pluralize .Name }}(); err == nil {
		total += n
	} else {
		return total, WrapErr(err)
	}
{{- end }}
	return total, nil
}

func (obj *DB) Open() (*Tx, error) {
	tx, err := obj.DB.Begin()
	if err != nil {
		return nil, WrapErr(err)
	}

	return &Tx{tx: tx, methods: obj.begin(tx)}, nil
}

type Tx struct {
	tx *sql.Tx
	methods
}

func (tx *Tx) Commit() (err error) {
	return WrapErr(tx.tx.Commit())
}

func (tx *Tx) Rollback() (err error) {
	return WrapErr(tx.tx.Rollback())
}

func (tx *Tx) DeleteAll() (total int64, err error) {
{{- range .StructsReverse }}
	if n, err := tx.Delete{{ pluralize .Name }}(); err == nil {
		total += n
	} else {
		return total, WrapErr(err)
	}
{{- end }}
	return total, nil
}

{{- range .Dialects }}

{{ $dbtype := .Name | printf "%sDB" }}
{{ $txtype := .Name | printf "%sTx" }}

type {{ $dbtype }} struct {
	impl *sql.DB
}

func (obj *{{ $dbtype }}) Schema() string {
return `
{{- .SchemaSQL -}}
`
}

func (obj *{{ $dbtype }}) logStmt(stmt string, args... interface{}) {
	{{ .Name }}LogStmt(stmt, args...)
}

func (obj *{{ $dbtype }}) begin(tx *sql.Tx) methods {
	return &{{ $txtype }}{
		impl: tx,
	}
}

type {{ $txtype }} struct {
	impl *sql.Tx
}

func (obj *{{ $txtype }}) logStmt(stmt string, args... interface{}) {
	{{ .Name }}LogStmt(stmt, args...)
}

func {{ .Name }}LogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		Logger("sql:\n%s\nargs:\n%v", stmt, args)
	}
}

{{- end }}

{{ range .Structs }}
{{ $struct := .Name }}

type {{ $struct }} struct {
{{- range .Fields }}
	{{ .Name }} {{ .Type }}
{{- end }}
}

{{- if .UpdatableFields }}

type {{ .UpdateStructName }} struct {
{{- range .UpdatableFields }}
{{- $fstruct := printf "%s%sField" $struct .Name }}
	{{ .Name }} *{{ $fstruct }}
{{- end }}
}
{{- end }}

{{- range .Fields }}
{{- $fstruct := printf "%s%sField" $struct .Name }}

type {{ $fstruct }} struct { v {{ .Type }} }
func {{ $struct }}{{ .Name }}(v {{ .Type }}) {{ if .Nullable }}*{{ end }}{{ $fstruct }} { return {{ if .Nullable }}&{{ end }}{{ $fstruct }}{v: v} }
func (u {{ $fstruct }}) columnName() string { return "{{ .Column }}" }
func (u *{{ $fstruct }}) value() interface{} { 
	if u == nil {
		return nil
	}
	return u.v
}
{{- if not .Nullable }}
func (u {{ $fstruct }}) Ref() *{{ $fstruct }} { return &u }
{{- end }}

{{- end -}}
{{- end }}
