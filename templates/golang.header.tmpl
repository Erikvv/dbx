// AUTOGENERATED BY github.com/spacemonkeygo/dbx
// DO NOT EDIT.

package {{ .Package }}

import (
	"database/sql"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/jmoiron/sqlx"
)

var WrapErr = func(err error) error {return err}
var Logger func(format string, args ...interface{})
var Now = time.Now

func loge(err error) {
	if Logger != nil && err != nil {
		Logger("error closing statement: %v", err)
	}
}

{{ range .Structs }}
type {{ .Name }} struct {
{{- range .Fields }}
	{{ .Name }} {{ .Type }} {{ .Tag }}
{{- end }}
}

{{- if .Updatable }}
{{ $struct := .Name }}
type {{ $struct }}Update interface {
	columnName() string
	value() interface{}
	private{{ $struct }}()
}
{{ range .UpdatableFields }}
{{ $upstruct := printf "%s%s" (cameldown $struct) .Name }}
type {{ $upstruct }} {{ .Type }}
func {{ $struct }}{{ .Name }}(v {{ .Type }}) {{ $struct }}Update { return {{ $upstruct }}(v) }
func (u {{ $upstruct }}) columnName() string { return "{{ .Column }}" }
func (u {{ $upstruct }}) value() interface{} { return {{ .Type }}(u) }
func (u {{ $upstruct }}) private{{ $struct }}() {}
{{- end -}}
{{- end -}}
{{- end }}

type DB struct {
	*sqlx.DB

	lru *lru
}

func Open(source string, lru_size int) (*DB, error) {
	db, err := sqlx.Connect({{ .Dialect | printf "%q" }}, source)
	if err != nil {
		return nil, WrapErr(err)
	}

	return &DB{
		DB: db,
		lru: newLRU(db, lru_size),
	}, nil
}

func (db *DB) Close() (err error) {
	db.lru.Purge()
	return WrapErr(db.DB.Close())
}

func (db *DB) prepare(stmt string) (prepared *sqlx.Stmt, replace func(), err error) {
	entry, err := db.lru.Get(stmt)
	if err != nil {
		return nil, nil, err
	}
	return entry.Stmt, func() { db.lru.Replace(entry) }, nil
}

func (db *DB) logStmt(stmt string, args... interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		Logger("sql: " + stmt + " args=%v", args)
	}
}

type Tx struct {
	*sqlx.Tx
	db *DB
}

func (db *DB) Open() (*Tx, error) {
	tx, err := db.DB.Beginx()
	if err != nil {
		return nil, WrapErr(err)
	}

	return &Tx{
		Tx: tx,
		db: db,
	}, nil
}

func (tx *Tx) Commit() (err error) {
	return WrapErr(tx.Tx.Commit())
}

func (tx *Tx) Rollback() (err error) {
	return WrapErr(tx.Tx.Rollback())
}

func (tx *Tx) prepare(stmt string) (prepared *sqlx.Stmt, replace func(), err error) {
	prepared, replace, err = tx.db.prepare(stmt)
	if err != nil {
		return nil, nil, err
	}
	return tx.Stmtx(prepared), replace, nil
}

func (tx *Tx) logStmt(stmt string, args... interface{}) {
	tx.db.logStmt(stmt, args...)
}

type entry struct {
	Stmt *sqlx.Stmt

	next, prev *entry
	key        string
	refs       int
}

type lru struct {
	mu       sync.Mutex
	db       *sqlx.DB
	capacity int
	root     entry
	index    map[string]*entry
}

// newLRU returns an initialized lru.
func newLRU(db *sqlx.DB, capacity int) *lru {
	l := &lru{
		db:       db,
		capacity: capacity,
		index:    make(map[string]*entry),
	}
	l.root.next = &l.root
	l.root.prev = &l.root
	return l
}

// insert inserts e after at, increments l.len.
func (l *lru) insert(e, at *entry) {
	n := at.next
	at.next = e
	e.prev = at
	e.next = n
	n.prev = e
}

// remove removes e from its list, decrements l.len
func (l *lru) remove(e *entry) {
	e.prev.next = e.next
	e.next.prev = e.prev
	e.next = nil // avoid memory leaks
	e.prev = nil // avoid memory leaks
}

func (l *lru) evict(capacity int) {
	if capacity < 0 {
		return
	}

	to_evict := len(l.index) - capacity
	current := &l.root
	for i := 0; i < to_evict; i++ {
		current = current.prev
		if current == &l.root {
			panic("index out of whack. race conditions?")
		}
		if current.refs > 0 {
			continue
		}
		// whoa boy is this subtle. l.remove blows away current.next and
		// current.prev. but current.next.prev will be mutated to be
		// current.prev for the next iteration!
		next_current := current.next

		l.remove(current)
		delete(l.index, current.key)
		loge(current.Stmt.Close())

		current = next_current
	}
}

func (l *lru) Get(key string) (*entry, error) {
	l.mu.Lock()
	defer l.mu.Unlock()

	e, ok := l.index[key]
	if ok {
		l.remove(e)
		l.insert(e, &l.root)
		e.refs++

		return e, nil
	}

	stmt, err := l.db.Preparex(l.db.Rebind(key))
	if err != nil {
		return nil, WrapErr(err)
	}

	e = &entry{
		Stmt: stmt,
		key:   key,
	}
	l.insert(e, &l.root)
	l.index[key] = e
	e.refs++

	return e, nil
}

func (l *lru) Replace(e *entry) {
	l.mu.Lock()
	defer l.mu.Unlock()

	e.refs--
	l.evict(l.capacity)
}

func (l *lru) Purge() {
	l.mu.Lock()
	defer l.mu.Unlock()

	l.evict(0)
}


