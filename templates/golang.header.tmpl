// AUTOGENERATED BY gopkg.in/spacemonkeygo/dbx.v1
// DO NOT EDIT.

package {{ .Package }}

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"
	"strconv"

{{- range .ExtraImports }}
	{{ .As }} "{{ .Package }}"
{{- end }}
)

// Prevent conditional imports from causing build failures
var _ = strconv.Itoa

var WrapErr = func(err error) error {return err}
var Logger func(format string, args ...interface{})
var Now = time.Now

type driver interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
}

var (
	notAPointer = errors.New("destination not a pointer")
	lossyConversion = errors.New("lossy conversion")
)

type DB struct {
	*sql.DB
	dbMethods
}

func Open(driver, source string) (db *DB, err error) {
	sql_db, err := sql.Open(driver, source)
	if err != nil {
		return nil, WrapErr(err)
	}
	defer func(sql_db *sql.DB) {
		if err != nil {
			sql_db.Close()
		}
	}(sql_db)

	if err := sql_db.Ping(); err != nil {
		return nil, WrapErr(err)
	}

	var impl dbMethods
	switch driver {
{{- range .Dialects }}
	case {{ .Name | printf "%q" }}:
		impl = new{{ .Name }}(sql_db)
{{- range .ExecOnOpen }}
		if _,  err := sql_db.Exec({{ printf "%q" . }}); err != nil {
			return nil, WrapErr(err)
		}
{{- end }}
{{- end }}
	default:
		return nil, WrapErr(fmt.Errorf("unsupported driver %s", driver))
	}

	return &DB{
		DB: sql_db,
		dbMethods: impl,
	}, nil
}

func (obj *DB) Close() (err error) {
	return WrapErr(obj.DB.Close())
}

func (obj *DB) Open(ctx context.Context) (*Tx, error) {
	tx, err := obj.DB.Begin()
	if err != nil {
		return nil, WrapErr(err)
	}

	return &Tx{
		tx: tx,
		txMethods: obj.wrapTx(tx),
	}, nil
}

func DeleteAll(ctx context.Context, db *DB) (int64, error) {
	tx, err := db.Open(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err == nil {
			err = WrapErr(tx.Commit())
			return
		}

		if err_rollback := tx.Rollback(); err_rollback != nil {
			if Logger != nil {
				Logger("delete-all: rollback failed: %v", WrapErr(err_rollback))
			}
		}
	}()
	return tx.deleteAll(ctx)
}

type Tx struct {
	tx *sql.Tx
	txMethods
}

type dialectTx struct {
	tx *sql.Tx
}

func (tx *dialectTx) Commit() (err error) {
	return WrapErr(tx.tx.Commit())
}

func (tx *dialectTx) Rollback() (err error) {
	return WrapErr(tx.tx.Rollback())
}

{{- range .Dialects }}

{{- $dbtype := .Name | printf "%sDB" -}}
{{- $txtype := .Name | printf "%sTx" -}}
{{- $impltype := .Name | printf "%sImpl" }}

type {{ $impltype }} struct {
	driver driver
}

func (obj *{{ $impltype }}) logStmt(stmt string, args... interface{}) {
	{{ .Name }}LogStmt(stmt, args...)
}

type {{ $dbtype }} struct {
	db *sql.DB
	*{{ $impltype }}
}

func new{{ .Name }}(db *sql.DB) *{{ $dbtype }} {
	return &{{ $dbtype }}{
		db: db,
		{{ $impltype }}: &{{ $impltype }}{
			driver: db,
		},
	}
}

func (obj *{{ $dbtype }}) Schema() string {
	return `{{ .SchemaSQL }}`
}

func (obj *{{ $dbtype }}) wrapTx(tx *sql.Tx) txMethods {
	return &{{ $txtype }}{
		dialectTx: dialectTx{tx: tx},
		{{ $impltype }}: &{{ $impltype }}{
			driver: tx,
		},
	}
}

type {{ $txtype }} struct {
	dialectTx
	*{{ $impltype }}
}

func {{ .Name }}LogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		Logger("sql:\n%s\nargs:\n%q", stmt, args)
	}
}

{{- end }}

{{ range .Structs }}
{{- $struct := .Name -}}
{{- $createstruct := .CreateStructName -}}
{{- $updatestruct := .UpdateStructName }}

type {{ $struct }} struct {
{{- range .Fields }}
	{{ .Name }} {{ .Type }}
{{- end }}
}

func ({{ $struct }}) _Table() string { return "{{ .Table }}" }

{{- if .OptionalInsertFields }}

type {{ $createstruct }} struct {
{{- range .OptionalInsertFields }}
	{{ .Name }} {{ .StructName }}
{{- end }}
}

{{- end }}

type {{ $updatestruct }} struct {
{{- range .UpdatableFields }}
	{{ .Name }} {{ .StructName }}
{{- end }}
}

{{- range .Fields }}
{{- $fstruct := .StructName }}
{{- $ctor := printf "%s_%s" .ModelName .Name }}

type {{ $fstruct }} struct {
	_set bool
	_value {{ .Type }}
}

func {{ $ctor }}(v {{ .CtorValue }}) {{ $fstruct }} {
{{- if .MutateFn }}
	v = {{ .MutateFn }}(v)
{{- end }}
	return {{ $fstruct }}{ _set: true, _value: {{ if .TakeAddr }}&{{ end }}v }
}
{{ if .Nullable }}
func {{ $ctor }}_Raw(v {{ .Type }}) {{ $fstruct }} {
	if v == nil {
		return {{ $ctor }}_Null()
	}
	return {{ $ctor }}({{ if .TakeAddr }}*{{ end }}v)
}

func {{ $ctor }}_Null() {{ $fstruct }} {
	return {{ $fstruct }}{ _set: true }
}
{{ end }}

func (f {{ $fstruct }}) value() interface{} { if !f._set { return nil }; return f._value }

func ({{ $fstruct }}) _Column() string { return "{{ .Column }}" }

{{- end -}}
{{- end }}

func toUTC(t time.Time) time.Time {
	return t.UTC()
}
